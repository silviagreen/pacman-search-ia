<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Relazione - Progetto I.A. 2013</title>
        <link href="css/bootstrap.min.css" rel="stylesheet" media="screen">
        <link href="css/bootstrap-responsive.min.css" rel="stylesheet">
        <link href="css/docs.css" rel="stylesheet">
        <link href="css/stile.css" rel="stylesheet" media="screen">
        <style type="text/css">
        </style>
    </head>
    <body data-spy="scroll" data-target=".bs-docs-sidebar">
        <div class="container">
            <div class="titolo">
                <h1>Ricerca in Pac-Man</h1>
                <p class="lead nomi">
                    Rango Massimiliano, Segato Silvia
                </p>
                <p class="lead">
                    Corso di Intelligenza Artificiale 2012 / 2013
                </p>
                <img src="img/pacman_game.gif"/>
            </div>
            <div class="row-fluid">
	            <div class="span3 bs-docs-sidebar indice">
	                <ul class="nav nav-list bs-docs-sidenav affix-top">
	                <!--con solo affix l'indice è sempre sullo schermo anche durante lo scroll, 
	                	con affix-top l'indice è fisso nel punto della pagina -->	
	                    <li>
	                        <a href="#introduzione">
	                        	<i class="icon-chevron-right"></i>
	                        	Introduzione
	                    	</a>
	                    </li>
	                    <li>
	                        <a href="#consuntivo">
	                        	<i class="icon-chevron-right"></i>
	                        	Consuntivo Ore
	                        	</a>
	                    </li>
	                    <li>
	                        <a href="#struttura">
	                        	<i class="icon-chevron-right"></i>
	                        	Struttura del Progetto
	                        	</a>
	                    </li>
	                    <li>
	                        <a href="#ptfissato">
	                        	<i class="icon-chevron-right"></i>
	                        	Trovare un Punto Fissato
	                        	</a>
	                    </li>
	                    <li>
	                        <a href="#angoli">
	                        	<i class="icon-chevron-right"></i>
	                        	Trovare Tutti gli Angoli
	                        	</a>
	                    </li>
	                    <li>
	                        <a href="#punti">
	                        	<i class="icon-chevron-right"></i>
	                        	Passare per Tutti i Punti
	                        	</a>
	                    </li>
	                    <li>
	                        <a href="#conclusioni">
	                        	<i class="icon-chevron-right"></i>
	                        	Conclusioni
	                        	</a>
	                    </li>
	                </ul>
	            </div>
	            <div class="span9">
		            <div id="introduzione">
		                <h2>Introduzione</h2>
		                <p>
		                    Il progetto è stato realizzato nell'anno accademico 2012/2013 per il corso di Intelligenza Artificiale dell'Università degli Studi di Padova e si basa sul primo di una serie di progetti parzialmente implementati messi a disposizione dalla University of Califonia, Berkeley e disponibili alla pagina <a href="http://www-inst.eecs.berkeley.edu/~cs188/pacman/pacman.html">http://www-inst.eecs.berkeley.edu/~cs188/pacman/pacman.html</a>.
		                    <br/>
		                    Lo scopo di questo progetto è quello di implementare alcuni algoritmi di ricerca su grafi applicandoli a tre diversi problemi inerenti il mondo di Pac-man. In questo contesto Pac-Man si trova da solo in un labirinto di dimensioni e disposizione dei muri casuali e deve riuscire a mangiare tutto il cibo presente, collocato in modo diverso a seconda del particolare problema preso in esame.
		                </p>
		            </div>
		            <div id="consuntivo">
		                <h2>Consuntivo Ore</h2>
		                <p>
		                    Il progetto ha richiesto un totale di 50 ore complessive (25 ore a persona), suddivise nel seguente modo:
		                </p>
		                <table class="table">
		                    <thead>
		                        <tr>
		                            <th>Fase</th>
		                            <th>Ore</th>
		                            <th>Descrizione</th>
		                        </tr>
		                    </thead>
		                    <tbody>
		                        <tr>
		                            <th>Analisi dei requisiti</th><td>11</td><td>Studio di Python, studio della struttura del progetto e dei file da modificare.</td>
		                        </tr>
		                        <tr>
		                            <th>Progettazione</th><td>20</td><td>Progettazione dell'implementazione degli algoritmi di ricerca su grafo, euristiche e strutture dati da utilizzare.</td>
		                        </tr>
		                        <tr>
		                            <th>Programmazione</th><td>10</td><td>Implementazione algoritmi, euristiche e strutture dati.</td>
		                        </tr>
		                        <tr>
		                            <th>Test e Raccolta Dati</th><td>4</td><td>Confronto tra i diversi algoritmi, tra le diverse euristiche considerando il tempo d'esecuzione, il costo del percorso trovato e il numero di nodi espansi.</td>
		                        </tr>
		                        <tr>
		                            <th>Documentazione</th><td>5</td><td>Stesura relazione finale e presentazione.</td>
		                        </tr>
		                    </tbody>
		                </table>
		            </div>
		            <div id="struttura">
		                <h2>Struttura del Progetto</h2>
		                <p>
		                	Il codice del progetto si trova all’interno della cartella <strong>/search</strong>.Al suo interno si trovano la cartella <strong>/layout</strong> che contiene le strutture dei labirinti con le posizioni dei cibi e la posizione iniziali di Pacman, e una serie di file Python che costituiscono il cuore del gioco.
		                	<br />
		                	I file riguardanti la grafica non sono stati usati per lo svolgimento del progetto e sono:
		                	
		                	<table class="table">
		                    <thead>
		                        <tr>
		                            <th>Nome File</th>
		                            <th>Descrizione</th>
		                        </tr>
		                    </thead>
		                    <tbody>
		                        <tr>
		                            <td>graphicDisplay.py</td><td>grafica per PacMan</td>
		                        </tr>
		                        <tr>
		                            <td>graphicUtil.py</td><td>supporto per la grafica</td>
		                        </tr>
		                        <tr>
		                            <td>textDisplay.py</td><td>grafica ASCII per PacMan</td>
		                        </tr>
		                        <tr>
		                            <td>ghostAgents.py</td><td>agenti per controllare i fantasmi</td>
		                        </tr>
		                        <tr>
		                            <td>keyboardAgents.py</td><td>interfaccia per controllare PacMan con la tastiera</td>
		                        </tr>
		                        <tr>
		                            <td>layout.py</td><td>codice per leggere i file contenuti in <strong>/layout</strong> </td>
		                        </tr>
		                    </tbody>
		                </table>	
		                I file che è stato necessario comprendere ai fini dello svolgimento del problema sono i seguenti:
		                	<table class="table">
		                    <thead>
		                        <tr>
		                            <th>Nome File</th>
		                            <th>Descrizione</th>
		                        </tr>
		                    </thead>
		                    <tbody>
		                        <tr>
		                            <td>pacman.py</td><td>File principale che esegue il gioco; in particolare è stato necessario prestare attentione al tipo GameState</td>
		                        </tr>
		                        <tr>
		                            <td>game.py</td><td>Contiene la logica del mondo di Pacman</td>
		                        </tr>
		                        <tr>
		                            <td>util.py</td><td>Contiene le strutture dati utili per l’implementazione degli algoritmi di ricerca</td>
		                        </tr>
		                   </tbody>
		                </table>
		            I file che contengono il nostro lavoro sul progetto sono:
		            <table class="table">
		                    <thead>
		                        <tr>
		                            <th>Nome File</th>
		                            <th>Descrizione</th>
		                        </tr>
		                    </thead>
		                    <tbody>
		                        <tr>
		                            <td>search.py</td><td>Contiene l’implememtazione di tutti gli algoritmi di ricerca</td>
		                        </tr>
		                        <tr>
		                            <td>searchAgents.py</td><td>Contiene l’implementazione di tutti gli agenti</td>
		                        </tr>
		                        
		                   </tbody>
		                </table>
		               </p> 
		               <h3>Come avviare il gioco</h3>
		               <p>
		               	Il gioco si avvia sempre tramite riga di comando. È possibile controllare Pacman con la tastiera (e quindi giocare al gioco vero e proprio) con il seguente comando:
		               <pre>python pacman.py   (1)</pre>
		               Nel corso del progetto è stato necessario utilizzare diversi tipi di layout, algoritmo (con euristica per quelli che ne utilizzano una), agenti in base al problema considerato. Tali cambiamenti vengono attuati via riga di comando specificando le opzioni  dopo  (1); la lista delle opzioni è elencata eseguendo
		               <pre>python pacman.py –h</pre>
		               Tutti i comandi che sono stati utilizzati nel progetto sono contenuti in <strong>/search/command.txt</strong>.
		               </p>
		            </div>
		            <div id="ptfissato">
		                <h2>Trovare un Punto Fissato</h2>
		                <p>
		                    Il primo problema preso in considerazione consiste nel far raggiungere a Pac-man un punto fissato all’interno del labirinto tramite diversi algoritmi di ricerca visti a lezione, nello specifico: depth-first, breadth-first, costo uniforme e A*.
		                    La rappresentazione dei nodi nel grafo di ricerca è data dalla funzione <code>getSuccessors</code> della classe <code>PositionSearchProblem</code>. Un nodo è rappresentato dalle coordinate x e y nel labirinto, dall'insieme di azioni e dal costo complessivo per arrivare a quello stato.
		                    Si è deciso di implementare innanzitutto una funzione di ricerca generica che utilizzasse come frontiera una lista astratta, istanziata a seconda del caso specifico come una pila, una coda, o una coda con priorità.
		                    La <code>genericSearch</code> è quindi definita come segue:
		                </p>
		                <pre>
		def genericSearch(problem, frontiera, euristica=nullHeuristic):
		    esplorati = []
		    frontiera.push((problem.getStartState(), [] , 0), 0)
		  
		    while(not(frontiera.isEmpty())):
		        stato, azioni, costo = frontiera.pop()
		    
		        if problem.isGoalState(stato):
		            return azioni #soluzione corrispondente
		    
		        esplorati.append(stato)
		        successori = problem.getSuccessors(stato)
		    
		        for statoSuccessore, azioneSuccessore, costoSuccessore in successori:
		            nuovaAzione = azioni + [azioneSuccessore]
		            nuovoCosto = costo + costoSuccessore #g(n)
		            nodoSuccessore = (statoSuccessore, nuovaAzione, nuovoCosto)
		            if statoSuccessore not in esplorati and not frontiera.contains(statoSuccessore, nuovoCosto):
		                frontiera.push(nodoSuccessore, nuovoCosto + euristica(statoSuccessore, problem))
		  
		    return None
		                </pre>
		                <p>
		                    Finché la frontiera non è vuota o non si raggiunge lo stato goal, viene estratto l’elemento successivo (in modo dipendente dal supporto di memorizzazione specifico), viene ricavata la lista dei successori del nodo corrente e quelli non ancora esplorati vengono aggiunti alla frontiera.
		                    Le implementazioni degli algoritmi specifici risultano a questo punto triviali, in quanto è sufficiente istanziare il supporto di memorizzazione corretto.
		                </p>
		                <h3>Depth-first Search:</h3>
		                <pre>
		def depthFirstSearch(problem):
		    "Search the deepest nodes in the search tree first"
		    frontiera = util.Stack()
		    return genericSearch(problem, frontiera)
		                </pre>
		                <p>
		                La frontiera è implementata come una pila LIFO, in questo modo viene estratto sempre il nodo inserito per ultimo, il che realizza la visita del grafo in profondità. L'algoritmo è stato eseguito sui labirinti <code>tinyMaze</code>, <code>mediumMaze</code> e <code>bigMaze</code>. I risultati ottenuti sono i seguenti:
		                </p>
		                <table class="table">
		                    <thead>
		                        <tr>
		                            <th>Layout</th>
		                            <th>Tempo impiegato (s)</th>
		                            <th>Nodi espansi</th>
		                            <th>Costo percorso</th>
		                        </tr>
		                    </thead>
		                    <tbody>
		                        <tr>
		                            <td>tinyMaze</td>
		                            <td>0.0</td>
		                            <td>15</td>
		                            <td>10</td>
		                        </tr>
		                        <tr>
		                            <td>mediumMaze</td>
		                            <td>0.0</td>
		                            <td>146</td>
		                            <td>130</td>
		                        </tr>
		                        <tr>
		                            <td>bigMaze</td>
		                            <td>0.1</td>
		                            <td>390</td>
		                            <td>210</td>
		                        </tr>
		                    </tbody>
		                </table>
		                <h3>Breadth-first Search:</h3>
		                <pre>
		def breadthFirstSearch(problem):
		    "Search the shallowest nodes in the search tree first."
		    frontiera = util.Queue()
		    return genericSearch(problem, frontiera)
		                </pre>
		                <p>
		                La frontiera è implementata come una coda FIFO, in questo modo viene estratto sempre il nodo inserito per primo, il che realizza la visita del grafo in ampiezza. L'algoritmo è stato eseguito sui labirinti <code>tinyMaze</code>, <code>mediumMaze</code> e <code>bigMaze</code>. I risultati ottenuti sono i seguenti:
		                </p>
		                <table class="table">
		                    <thead>
		                        <tr>
		                            <th>Layout</th>
		                            <th>Tempo impiegato (s)</th>
		                            <th>Nodi espansi</th>
		                            <th>Costo percorso</th>
		                        </tr>
		                    </thead>
		                    <tbody>
		                        <tr>
		                            <td>tinyMaze</td>
		                            <td>0.0</td>
		                            <td>15</td>
		                            <td>8</td>
		                        </tr>
		                        <tr>
		                            <td>mediumMaze</td>
		                            <td>0.0</td>
		                            <td>269</td>
		                            <td>68</td>
		                        </tr>
		                        <tr>
		                            <td>bigMaze</td>
		                            <td>0.1</td>
		                            <td>620</td>
		                            <td>210</td>
		                        </tr>
		                    </tbody>
		                </table>
		                <h3>Uniform Cost Search:</h3>
		                <pre>
		def uniformCostSearch(problem):
		    "Search the node of least total cost first."
		    frontiera = util.PriorityQueue()
		    return genericSearch(problem, frontiera)
		                </pre>
		                <p>
		                La frontiera è implementata come una coda con priorità, in questo modo viene estratto per primo sempre il nodo con priorità più alta. L'algoritmo è stato eseguito sui labirinti <code>mediumMaze</code> come tutti gli altri algoritmi. Inoltre è stato testato sul labirinto <code>mediumDottedMaze</code> con agente <code>StayEastSearchAgent</code>, che penalizza i passi verso la parte sinistra del labirinto, e sul labirinto <code>mediumScaryMaze</code> con agente <code>StayWestSearchAgent</code> che penalizza i passi verso la parte destra del labirinto. I risultati ottenuti sono i seguenti:
		                </p>
		                <table class="table">
		                    <thead>
		                        <tr>
		                            <th>Layout</th>
		                            <th>Tempo impiegato (s)</th>
		                            <th>Nodi espansi</th>
		                            <th>Costo percorso</th>
		                        </tr>
		                    </thead>
		                    <tbody>
		                        <tr>
		                            <td>mediumMaze</td>
		                            <td>0.0</td>
		                            <td>268</td>
		                            <td>68</td>
		                        </tr>
		                        <tr>
		                            <td>mediumDottedMaze</td>
		                            <td>0.0</td>
		                            <td>190</td>
		                            <td>1</td>
		                        </tr>
		                        <tr>
		                            <td>mediumScaryMaze</td>
		                            <td>0.0</td>
		                            <td>108</td>
		                            <td>68719479864</td>
		                        </tr>
		                    </tbody>
		                </table>
		                <p>
		                	Il costo dei percorsi trovati dall'agente <code>StayEastSearchAgent</code> e <code>StayWestSearchAgent</code> è molto basso nel primo caso e molto alto nel secondo, a causa delle loro funzioni di costo. Il primo infatti eleva 0.5 al valore della coordinata x (maggiore è il valore di x, minore è il costo), rendendo la somma dei costi sempre minore di 1. Il secondo invece eleva 2 al valore della coordinata x, in questo modo maggiore è il valore di x, maggiore è il costo.
	                	</p> 
		                <h3>A* Search:</h3>
		                <pre>
		def aStarSearch(problem, heuristic=nullHeuristic):
		    "Search the node that has the lowest combined cost and heuristic first."
		    frontiera = util.PriorityQueue()
		    return genericSearch(problem, frontiera, heuristic)
		                </pre>
		                <p>
		                La frontiera è implementata come una coda con priorità, in cui la priorità è data dall'euristica passata all'algoritmo. L'algoritmo è stato eseguito sui labirinti <code>mediumMaze</code> come tutti gli altri algoritmi. Inoltre è stato testato sul labirinto <code>bigMaze</code> con euristica nulla e con la distanza di Manhattan. Quest'ultima restituisce la somma dei valori assoluti delle differenze tra le coordinate dello stato corrente e del goal. I risultati ottenuti sono i seguenti:
		                </p>
		                <table class="table">
		                    <thead>
		                        <tr>
		                            <th>Layout</th>
		                            <th>Euristica</th>
		                            <th>Tempo impiegato (s)</th>
		                            <th>Nodi espansi</th>
		                            <th>Costo percorso</th>
		                        </tr>
		                    </thead>
		                    <tbody>
		                        <tr>
		                            <td>mediumMaze</td>
		                            <td>Manhattan Distance</td>
		                            <td>0.0</td>
		                            <td>221</td>
		                            <td>68</td>
		                        </tr>
		                        <tr>
		                            <td>bigMaze</td>
		                            <td>Null</td>
		                            <td>0.1</td>
		                            <td>619</td>
		                            <td>210</td>
		                        </tr>
		                        <tr>
		                            <td>bigMaze</td>
		                            <td>Manhattan Distance</td>
		                            <td>0.1</td>
		                            <td>538</td>
		                            <td>210</td>
		                        </tr>
		                    </tbody>
		                </table>
		                <p>
		                Si può notare come in mancanza di un euristica, l'algoritmo diventa esattamente la ricerca con costi uniformi. Utilizzando la distanza di Manhattan invece si nota come l'algoritmo riesca a trovare una soluzione pià velocemente. Questo tipo di euristica è ammissibile e consistente pertanto trova sempre la soluzione ottima. L'ammissibilità deriva dal fatto che non sovrastima mai il costo della soluzione ottima, essendo la distanza di Manhattan il minor numero di passi per raggiungere un punto in assenza di muri. La consistenza invece è verificata poichè ogni passo ha costo 1 ed ogni passo avvicina al più di 1 Pac-man al cibo: la disequazione h(n) &le; h(n') + 1 è pertanto vera.
	                	</p>
		                <p>
		                	Prendendo come metodo di confronto i dati ottenuti sul <code>mediumMaze</code> è evidente che tra questi algoritmi, a "vincere" è A* con euristica distanza di Manhattan, espandendo 221 nodi. L'algoritmo Depth-first infatti trova la soluzione espandendo solo 146 nodi, ma non riesce a trovare quella ottima, essendo il costo del percorso trovato 130. 
	                	</p>
		            </div>
		            <div id="angoli">
		            	<h2>Trovare Tutti gli Angoli</h2>
		            	<h3>Struttura del problema</h3>
		            	<p>
		            		In questo nuovo problema vengono utilizzati i layout cornerMazes; questi contengono 4 puntini, uno in ogni angolo del labirinto e PacMan, attraverso gli algoritmi di ricerca, deve essere in grado di trovare il percorso più breve attraverso il labirinto che tocchi tutti e quattro gli angoli.		            		
		            		La rappresentazione degli stati scelta per questo problema è la seguente:
		            		<br /><br />
		            		(posizione corrente di PacMan, angoli già visitati).
		            		<br /><br />
		            		Tale rappresentazione è nata dopo lo studio attento dei problemi già implementati all’interno del file searchAgents.py ed utilizza le sole parti del GameState che sono necessarie, come indicatoci dalla consegna (sebbene ciò comporti allo stato di “ricordarsi” degli angoli visitati in precedenza.
Quindi lo stato iniziale è (posizione iniziale di PacMan, angoli visitati), dove in angoli visitati ci sarà la posizione iniziale di pacman se questa è un angolo, altrimenti è vuoto.
								<pre>self.statoIniziale = (self.startingPosition, angoliVisitati)</pre>
							Il controllo per lo stato goal consiste nel confrontare l’insieme degli angoli del problema con l’insieme degli angoli visitati. Se i due insiemi sono uguali, allora lo stato è uno stato goal.
		            		<pre>def isGoalState(self, state):     
    return set(state[1]) == set(self.corners) </pre>
    						La funzione sucessore, invece, ritorna gli stati sucessori come un insieme di triple (così come indicatoci nella consegna); ciascuna tripla è composta da:
    						<ul>
    							<li>prossimo stato</li>
    							<li>l’azione fatta da pacMan per raggiungere quello stato, ovvero il punto cardinale verso cui si è mosso</li>
    							<li>il costo dell’azione per raggiungere quello stato (che è 1)</li>
    						</ul>
    						
    						Ciascuna tripla è costruita come segue:
    						<ol>
    							<li>a partire dalla posizione di pacman, si calcola la nuova posizione in cui pacman sarebbe se si spostasse di una casella seguendo uno dei quattro punti cardinali.</li>
    							<li>se tale nuova posizione è valida (ovvero non è un muro), allora costruisce la tripla descritta sopra, aggiornando l’insieme degli angoli visitati per il prossimo stato se la nuova posizione è un angolo non ancora visitato.</li>
    							<li>si ripetono queste operazioni per ciascun punto cardinale.</li>
    						</ol>
    						
    						<pre>def getSuccessors(self, state):
    successors = []
    for action in [Directions.NORTH, Directions.SOUTH, Directions.EAST, Directions.WEST]:
         x,y = state[0]
         dx, dy = Actions.directionToVector(action)
         prossimaPosizione = nextx, nexty = int(x + dx), int(y + dy)
         hitsWall = self.walls[nextx][nexty]

         if not hitsWall:
             angoliVisitati = set(state[1])
             if prossimaPosizione in self.corners and prossimaPosizione not in angoliVisitati:
                 angoliVisitati.add(prossimaPosizione)
             prossimoStato = (prossimaPosizione, angoliVisitati)
             costoAzione = self.costFn(prossimoStato)
             successors.append( (prossimoStato , action, costoAzione) )             
    
    self._expanded += 1
    return successors</pre>
    Tale problema è implementato nel file <strong>searchAgents.py</strong>, nella classe <code>CornersProblem</code>, seguendo la struttura e le firme dei metodi a disposizione. Le funzioni che sono state da noi implementate sono il costruttore, <code>getStartState</code>, <code>isGoalState</code>, <code>getSuccessors</code>.
		            	</p>
		   <h3>Euristica</h3>
		   <p>
		   	La seconda consegna richiedeva l’implementazione di una euristica per poter risolvere il problema utilizzando l’algoritmo A*. è richiesto che l’euristica sia ammissibile.
		   	L’euristica scelta si comporta come segue:
		   	<ol>
		   		<li>Tra gli angoli che Pacman non ha ancora visitato, si sceglie quello più vicino alla posizione corrente di pacman e si memorizza la distanza.</li>
		   		<li>Dopo di che si sceglie l’angolo più vicino (non ancora visitato) all’angolo scelto al punto 1 e si somma la distanza tra questi due angoli a quella memorizzata al punto.</li>
		   		<li>Per ciascun angolo non ancora visitato, si sceglie quello più vicino rispetto all’angolo considerato subito prima e si sommano le distanze tra queste coppie di angoli.</li>
		   		<li>La somma tra le distanze è ritornata </li>
		   	</ol>
		   	Tale euristica è ammissibile in quanto si tratta della soluzione del problema rilassato in cui pacman si trova in un labirinto senza muri. È soluzione in quanto pacman, dopo aver raggiunto l’angolo più vicino alla sua posizione iniziale segue il perimetro per poter visitare tutti gli altri angoli.
		   </p>
		   
		   <h3>Test</h3>
		   <p>Al fine di verificare se la nostra rappresentazione degli stati era corretta, abbiamo seguito il test proposto nella consegna. Tale consiste nell’ eseguire i due comandi sottostanti; la rappresentazione del problema doveva far si che l’agente riuscisse a risolvere con successo i due problemi lanciati.</p>
		   <pre>python pacman.py -l tinyCorners -p SearchAgent –a fn=bfs,prob=CornersProblem</pre>
		   <pre>python pacman.py -l mediumCorners -p SearchAgent -a fn=bfs,prob=CornersProblem </pre>
		   La nostra rappresentazione risolve correttamente i due problemi.
		   <br />
		   L’euristica invece è stata testata utilizzando tre tipi di distanze: la disanza di manhattan, la distanza euclidea e la distanza di Chebyshev. Il confronto tra i dati ottenuti ci sottolinea come la distanza Manhattan sia dominante nei confronti delle altre due, mentre la distanza euclidea è dominante solo sulla distanza di Chebyshev 
		   <br />
		   I dati ottenuti con il layout <code>mediumCorners</code> sono i seguenti:
		   <table class="table">
		                    <thead>
		                        <tr>
		                            <th>Euristica</th>
		                            <th>Tempo impiegato (s)</th>
		                            <th>Nodi espansi</th>
		                            <th>Costo percorso</th>
		                        </tr>
		                    </thead>
		                    <tbody>
		                        <tr>
		                            <td>Manhattan Distance</td>
		                            <td>0.1</td>
		                            <td>106</td>
		                            <td>755</td>
		                        </tr>
		                        <tr>
		                            <td>Euclidean Distance</td>
		                            <td>0.1</td>
		                            <td>106</td>
		                            <td>818</td>
		                        </tr>
		                        <tr>
		                            <td>Chebyshev Distance</td>
		                            <td>0.2</td>
		                            <td>106</td>
		                            <td>888</td>
		                        </tr>
		                    </tbody>
		                </table>
		   
		   I dati ottenuti con il layout <code>bigCorners</code> sono i seguenti:
		   <table class="table">
		                    <thead>
		                        <tr>
		                            <th>Euristica</th>
		                            <th>Tempo impiegato (s)</th>
		                            <th>Nodi espansi</th>
		                            <th>Costo percorso</th>
		                        </tr>
		                    </thead>
		                    <tbody>
		                        <tr>
		                            <td>Manhattan Distance</td>
		                            <td>0.4</td>
		                            <td>162</td>
		                            <td>1813</td>
		                        </tr>
		                        <tr>
		                            <td>Euclidean Distance</td>
		                            <td>0.5</td>
		                            <td>162</td>
		                            <td>2044</td>
		                        </tr>
		                        <tr>
		                            <td>Chebyshev Distance</td>
		                            <td>0.6</td>
		                            <td>162</td>
		                            <td>2296</td>
		                        </tr>
		                    </tbody>
		                </table>
		   <br />
		   Per risolvere il problema degli angoli con A* e la nostra euristica è sufficiente eseguire questo comando: 
		   <pre>python pacman.py -l mediumCorners -p AStarCornersAgent -z 0.5</pre>
		   
		            
		            </div>
            	</div>
            </div>
    	</div>
    </body>
</html>